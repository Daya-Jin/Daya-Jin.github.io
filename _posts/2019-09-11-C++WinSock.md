---
layout: post
title:  "C++ WinSock2"
categories: programming
tags: C++ socket Windows
---

* content
{:toc}

## WinSock2

WinSock2是在Windows下实现socket编程的一个库。一个微软官方的简单C/S示例代码见此：([Server](https://github.com/Daya-Jin/CPP_Backend/blob/master/WinSock2/Demo/S.cpp)，[Client](https://github.com/Daya-Jin/CPP_Backend/blob/master/WinSock2/Demo/C.cpp))。可以看出一个最简单的单点C/S架构代码就比较复杂，这是因为官方Demo中加入了各种异常情况的处理。考虑到socket编程最需要关注的点在于收发步骤的逻辑实现，这里给出了一组简化版本的代码：([Server](https://github.com/Daya-Jin/CPP_Backend/blob/master/WinSock2/Demo/S_mini.cpp)，[Client](https://github.com/Daya-Jin/CPP_Backend/blob/master/WinSock2/Demo/C_mini.cpp))。

网络开发主要是围绕connecting、sending和receiving的逻辑来进行代码修改。

## 单点通信

下面给出一个简单的单点通信的C/S架构代码。

**PS**：这里其实传文本数据的细节我没理解，代码中传输的是一个```const char *```，即传输的是一个字符指针，单机测试是没问题，因为数据存储的地址是一样的。如果是两台不同的机器呢？直接传地址过去真的大丈夫？没有测试，仅猜测。

Server端```S.cpp```：

```c++
// 6. Receive and send data
...

char recvBuf[BUFFER_SIZE] = {};
while (true)
{
    int ret = recv(ClientSocket, recvBuf, BUFFER_SIZE, 0);
    if (ret <= 0)
        break;

    char sendBuf[BUFFER_SIZE];
    if (strcmp(recvBuf, "getAge") == 0)
        strcpy(sendBuf, "18");
    else if (strcmp(recvBuf, "getGender") == 0)
        strcpy(sendBuf, "male");
    else
        strcpy(sendBuf, "don't understand");
    send(ClientSocket, sendBuf, strlen(sendBuf) + 1, 0);
}

// 7. Disconnect
```

Client端```C.cpp```：

```c++
// 4. Send and receive data
...

while (true)
{
    char inputBuf[BUFFER_SIZE];
    scanf("%s", inputBuf);

    if (strcmp(inputBuf, "exit") == 0)
        break;
    else
    {
        send(ConnectSocket, inputBuf, strlen(inputBuf) + 1, 0);
        char recvBuf[BUFFER_SIZE];
        if (recv(ConnectSocket, recvBuf, BUFFER_SIZE, 0))
            printf("response: %s\n", recvBuf);
    }
}

// 5. Disconnect
```

## 报文封装

实际的网络传输数据是一种被称为报文的格式化数据，这里对C/S交互的数据做封装模拟报文。首先在两端的```cpp```代码中都定义好数据结构：

```c++
enum FLAG
{
	LOGIN,
	LOGOUT,
	NORMAL,
	ERR
};

struct DataPack
{
	FLAG flag = LOGIN;    // 状态位
	char s[32] = {};    // 消息主体
};
```

Server端```S.cpp```：

```c++
// 6. Receive and send data
// ...

while (true)
{
    DataPack recvDp = {};
    int l = recv(ClientSocket, (char*)&recvDp, sizeof(DataPack), 0);
    if (l <= 0)
    {
        printf("client exit!\n");
        break;
    }

    printf("[DEBUG]recvDp.flag: %d, recvDp.s: %s\n",
        recvDp.flag, recvDp.s);

    DataPack sendDp;
    switch (recvDp.flag)
    {
    case LOGIN:
        if (strcmp(recvDp.s, "123456") == 0)    // 固定密码
        {
            sendDp.flag = NORMAL;
            strcpy(sendDp.s, "login!");
        }
        else
        {
            sendDp.flag = ERR;
            strcpy(sendDp.s, "pswd err!");
        }

        send(ClientSocket, (char*)&sendDp, sizeof(DataPack), 0);
        break;
    case LOGOUT:
        sendDp.flag = NORMAL;
        strcpy(sendDp.s, "logout!");
        send(ClientSocket, (char*)&sendDp, sizeof(DataPack), 0);
        break;
    default:
        recvDp.flag = ERR;
        strcpy(recvDp.s, "unknow err!");
        send(ClientSocket, (char*)&recvDp, sizeof(DataPack), 0);
        break;
    }
}

// 7. Disconnect
```

```c++
// 4. Send and receive data
// ...

while (true)
{
    scanf("%s", cBuf);

    if (strcmp(cBuf, "exit") == 0)
        break;
    else if (strcmp(cBuf, "login") == 0)
    {
        DataPack sendDp;
        printf("enter your pswd:");
        scanf("%s", sendDp.s);
        send(ConnectSocket, (const char*)&sendDp, sizeof(DataPack), 0);

        DataPack recvDp = {};
        recv(ConnectSocket, (char*)&recvDp, sizeof(DataPack), 0);
        printf("recv msg: %s\n", recvDp.s);
    }
    else if (strcmp(cBuf, "logout") == 0)
    {
        DataPack sendDp;
        sendDp.flag = LOGOUT;
        strcpy(sendDp.s, "username");
        send(ConnectSocket, (const char*)&sendDp, sizeof(DataPack), 0);

        DataPack recvDp = {};
        recv(ConnectSocket, (char*)&recvDp, sizeof(DataPack), 0);
        printf("recv msg: %s\n", recvDp.s);
    }
    else
        printf("unknow cmd\n");
}

// 5. Disconnect
```
