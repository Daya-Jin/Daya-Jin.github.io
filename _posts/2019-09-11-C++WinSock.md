---
layout: post
title:  "C++ WinSock2"
categories: programming
tags: C++ socket Windows
---

* content
{:toc}

## WinSock2

WinSock2是在Windows下实现socket编程的一个库。一个微软官方的简单C/S示例代码见此：([Server](https://github.com/Daya-Jin/CPP_Backend/blob/master/WinSock2/Demo/S.cpp)，[Client](https://github.com/Daya-Jin/CPP_Backend/blob/master/WinSock2/Demo/C.cpp))。可以看出一个最简单的单点C/S架构代码就比较复杂，这是因为官方Demo中加入了各种异常情况的处理。考虑到socket编程最需要关注的点在于收发步骤的逻辑实现，这里给出了一组简化版本的代码：([Server](https://github.com/Daya-Jin/CPP_Backend/blob/master/WinSock2/Demo/S_mini.cpp)，[Client](https://github.com/Daya-Jin/CPP_Backend/blob/master/WinSock2/Demo/C_mini.cpp))。

网络开发主要是围绕connecting、sending和receiving的逻辑来进行代码修改。

## 单点通信

下面给出一个简单的单点通信的C/S架构代码。

**PS**：这里其实传文本数据的细节我没理解，代码中传输的是一个```const char *```，即传输的是一个字符指针，单机测试是没问题，因为数据存储的地址是一样的。如果是两台不同的机器呢？直接传地址过去真的大丈夫？没有测试，仅猜测。

Server端```S.cpp```：

```c++
// 6. Receive and send data
...

char recvBuf[BUFFER_SIZE] = {};
while (true)
{
    int ret = recv(ClientSocket, recvBuf, BUFFER_SIZE, 0);
    if (ret <= 0)
        break;

    char sendBuf[BUFFER_SIZE];
    if (strcmp(recvBuf, "getAge") == 0)
        strcpy(sendBuf, "18");
    else if (strcmp(recvBuf, "getGender") == 0)
        strcpy(sendBuf, "male");
    else
        strcpy(sendBuf, "don't understand");
    send(ClientSocket, sendBuf, strlen(sendBuf) + 1, 0);
}

// 7. Disconnect
```

Client端```C.cpp```：

```c++
// 4. Send and receive data
...

while (true)
{
    char inputBuf[BUFFER_SIZE];
    scanf("%s", inputBuf);

    if (strcmp(inputBuf, "exit") == 0)
        break;
    else
    {
        send(ConnectSocket, inputBuf, strlen(inputBuf) + 1, 0);
        char recvBuf[BUFFER_SIZE];
        if (recv(ConnectSocket, recvBuf, BUFFER_SIZE, 0))
            printf("response: %s\n", recvBuf);
    }
}

// 5. Disconnect
```

## 报文封装

实际的网络传输数据是一种被称为报文的格式化数据，这里对C/S交互的数据做封装模拟报文。首先在两端的```cpp```代码中都定义好数据结构：

```c++
enum FLAG
{
	NORMAL,
	ERR,
};

struct DataPack
{
	short n = sizeof(DataPack);    // 报文大小
	FLAG flag = NORMAL;
	int age = 18;
	char gender[8] = "male";
	char s[BUFFER_SIZE];
};
```

Server端```S.cpp```：

```c++
// 6. Receive and send data
...

char errBuf[] = "don't understand";
DataPack recvDp;
DataPack sendDp;
while (true)
{
    int ret = recv(ClientSocket, (char*)& recvDp, sizeof(DataPack), 0);
    if (ret <= 0)
        break;
    if (strcmp(recvDp.s, "getInfo") == 0)
    {
        sendDp.flag = NORMAL;
        send(ClientSocket, (const char*)& sendDp, sizeof(DataPack), 0);
    }
    else
    {
        sendDp.flag = ERR;
        strcpy(sendDp.s, errBuf);
        send(ClientSocket, (const char*)& sendDp, sizeof(DataPack), 0);
    }
}

// 7. Disconnect
```

```c++
// 4. Send and receive data
...

char inputBuf[BUFFER_SIZE];
DataPack sendDp;
DataPack recvDp;
while (true)
{
    scanf("%s", inputBuf);

    if (strcmp(inputBuf, "exit") == 0)
        break;
    else
    {
        strcpy(sendDp.s, inputBuf);
        send(ConnectSocket, (const char*)& sendDp, sizeof(DataPack), 0);

        recv(ConnectSocket, (char*)& recvDp, sizeof(DataPack), 0);
        if (recvDp.flag == ERR)
            printf("response: %s\n", recvDp.s);
        else
            printf("response: age %d, gender %s\n",
                recvDp.age, recvDp.gender);
    }
}

// 5. Disconnect
```
