---
layout: post
title:  "Collaborative Filtering"
categories: recommend
tags: recommend
---

* content
{:toc}

# 概述

**协同过滤**(Collaborative Filtering)是推荐系统中最经典的方法了，本文做一个简单的概述。

# User-based Collaborative Filtering

假设一个场景，我们想买一个东西或者想吃一个东西，但是自己不知道哪种东西比较好，那么通常的选择就是去询问身边有着相似喜好的朋友寻求推荐。这就是基于用户的协同过滤，核心思想就是相似的**用户**(user)会喜欢相似的**物品**(item)。

## 用户数据

为了在用户群体中找到跟自己相似的用户，很明显需要收集所有用户的数据，如所有用户对多个商品的评价，那么该数据的矩阵形状为$(n_{users},n_{items})$。在该矩阵中计算其他所有用户与指定用户的相似度，并使用前$k$个相似用户的数据来做推荐。推荐，肯定是该用户未曾见过或用过的东西，那么需要选出这些相似用户对指定用户未评价过的物品的评价数据，再做下一步计算。

相似用户对物品的加权评价为：相似度$\times$评分；另外，考虑到热门物品与冷门物品在评价人数上的巨大差别，还需要对加权平价做一个归一化的处理：加权评分/评价人数。对指定用户所有未接触过的物品做加权评价求和，按得分排序就得到了一个推荐物品序列。

假设现在有如下评价数据：

||item1|item2|item3|item4|item5|item6|
|-|-|-|-|-|-|-|
|user1|2.5|3.5|3|3.5|2.5|3|
|user2|3|3.5|1.5|5|3.5|3|
|user3|2.5|3|0|3.5|0|4|
|user4|0|3.5|3|0|4|4|
|user5|3|4|2|3|2|3|
|user6|3|4|0|5|3.5|3|
|user7|0|4.5|0|4|1|0|

现需要针对用户7做推荐。首先计算用户之间的相似度，这里使用：

$$
sim=\frac{1}{1+dist_{E}}
$$

其中$dist_{E}$为欧氏距离。与用户7最相似的前3个用户及其相似度为：

||user5|user6|user3|
|-|-|-|-|
|user7|0.1687|0.1652|0.1646|

用户7未接触过的物品为item1、item3和item6，相似用户对其的加权评价数据为：

||sim|item1|item3|item6|
|-|-|-|-|-|
|user3|0.1646|2.5*0.1646|0|4*0.1646|
|user5|0.1687|3*0.1687|2*0.1687|3*0.1687|
|user6|0.1652|3*0.1652|0|3*0.1652|
|item score|-|1.4138|0.3375|1.6607|
|sim sum|-|0.1646+0.1687+0.1652|0.1687|0.1646+0.1687+0.1652|
|scaling score|-|2.8349|2|3.33|

从上述表中可以发现，对于评价人数较少的item1在计算得分时会处于劣势，为了消除这种劣势，所有的得分还需除以一个可以表征评价人数的相似度和sim\_sum。

以上过程实现的是把物品推荐给人，如果对原数据做转置操作，就可以实现把人推荐给物品。

# Item-based Collaborative Filtering

从上节过程不难看出，每做一次推荐，都需要完整的扫描整个数据集，当然在实现上可以将相似度矩阵或者中间数据缓存起来以减少计算。但是注意到，对于大多数系统而言，用户是频繁变化的，但是物品却是稳定的，并且通常用户的数据量远远大于物品数量。所以在通常情况下使用的是基于物品的协同过滤，而不是基于用户的协同过滤。