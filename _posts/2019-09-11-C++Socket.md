---
layout: post
title:  "C++ SOCKET"
categories: programming
tags: C++ socket
---

* content
{:toc}

## WinSock2

WinSock2是在Windows下实现socket编程的一个库。一个微软官方的简单C/S示例代码见此：([Server](https://github.com/Daya-Jin/CPP_Backend/blob/master/Socket/Demo/S.cpp)，[Client](https://github.com/Daya-Jin/CPP_Backend/blob/master/Socket/Demo/C.cpp))。可以看出一个最简单的单点C/S架构代码就比较复杂，这是因为官方Demo中加入了各种异常情况的处理。考虑到socket编程最需要关注的点在于收发步骤的逻辑实现，这里给出了一组简化版本的跨平台代码：([Server](https://github.com/Daya-Jin/CPP_Backend/blob/master/Socket/Demo/S_mini.cpp)，[Client](https://github.com/Daya-Jin/CPP_Backend/blob/master/Socket/Demo/C_mini.cpp))。

网络开发主要是围绕connecting、sending和receiving的逻辑来进行代码修改，函数API查询地址[见此](https://docs.microsoft.com/zh-cn/windows/win32/api/_winsock/)。

## select模型

上述示例代码有两个缺陷，一是阻塞模式，二是单点通信。在网络编程中有一种IO复用的select模型，由操作系统实现。其原型为：

```c++
select(_In_ int nfds,    // 最大fd的ID
       _Inout_opt_ fd_set FAR * readfds,    // 可读fd集合
       _Inout_opt_ fd_set FAR * writefds,    // 可写fd集合
       _Inout_opt_ fd_set FAR * exceptfds,    // 异常fd集合
       _In_opt_ const struct timeval FAR * timeout);    // 阻塞时间，Linux下会重置
```

```fd_set```本质是一个socket数组，实际是一个结构体，它还有一个成员变量记录了集合中socket的数量。对`fd集合的操作依赖如下几个宏：

```FD_ZERO()```：清空某个fd集合，该宏应该在初始化一个fd集合后马上调用；
```FD_SET()```：把一个fd加入到集合中，该宏能自动去重；
```FD_CLR()```：从集合中删除一个fd，即使该fd不存在也不会报错；
```FD_ISSET()```：判断一个fd是否还在集合中。

在程序调用```select```函数之后会阻塞一段时间，直到超时或者任意fd发生事件。一旦```select```返回，```select```会修改```fd_set```仅保留需要处理的fd。因此在调用```select```之后只需要扫描```fd_set```中的fd进行处理即可。下面使用select模型实现一个支持多客户端的回显服务器。

### Server

首先实现server的回县功能：

```c++
int echo(SOCKET clientSock) {
    char data[BUFFER_SIZE] = {};
    if (recv(clientSock, data, BUFFER_SIZE, 0) > 0)
        send(clientSock, data, strlen(data) + 1, 0);
    else
        return -1;

    return 0;
}
```

基于模版代码，在成功监听端口之后使用select模型来处理事务：

```c++
// 4. Listen on the socket
// ...

char sBuf[BUFFER_SIZE] = "hello from server.";
std::vector<SOCKET> Client_pool;    // 客户端队列，#include<vector>

while (true) {
    fd_set fdRead;    // 读fd集合
    FD_ZERO(&fdRead);    // 清空集合
    FD_SET(listenSock, &fdRead);    // 监控ListenSocket
    SOCKET nfds = listenSock;    // 最大fd的值

    // 将所有客户套接字加入fdRead
    for (int i = 0; i < (int)Client_pool.size(); i++)
    {
        FD_SET(Client_pool[i], &fdRead);
        if (nfds < Client_pool[i])
            nfds = Client_pool[i];
    }

    // 调用select监控所有fd
    timeval t_val = { 1,0 };    // 阻塞时间1.0s
    if (select(nfds + 1, &fdRead, 0, 0, &t_val) < 0)
        break;    // error

    // 处理监听套接字
    if (FD_ISSET(listenSock, &fdRead))
    {
        // 5. Accept a connection
        sockaddr_in _cin = {};
        int len = sizeof(sockaddr_in);
#ifdef _WIN32
        SOCKET clientSock = accept(listenSock, (sockaddr*)&_cin, &len);
#else
        SOCKET clientSock = accept(listenSock, (sockaddr*)&_cin, (socklen_t*)&len);
#endif
        if (INVALID_SOCKET == clientSock)
            cout << "scoket invalid!" << endl;
        Client_pool.push_back(clientSock);

        send(clientSock, sBuf, strlen(sBuf) + 1, 0);
        cout << "recv a new client: IP " << inet_ntoa(_cin.sin_addr) << endl;

        FD_CLR(listenSock, &fdRead);    // 从集合中删除
    }

    // 6. Receive and send data
    // 处理有事件发生的客户端socket
    for (int i = Client_pool.size() - 1; i >= 0; i--) {
        if (FD_ISSET(Client_pool[i], &fdRead)) {
            /*判断client是否下线，并删除client的socket*/
            if (echo(Client_pool[i]) == -1) {
                std::vector<SOCKET>::iterator iter = Client_pool.begin() + i;
                if (iter != Client_pool.end())    // 客户连接数非空
                    Client_pool.erase(iter);
            }
        }
    }

    cout << "idle time..." << endl;
}
```

因为使用了vector数组来维护客户端socket，因此在清理时需要注意：

```c++
// 7. Disconnect
for (int i = (int)Client_pool.size() - 1; i >= 0; i--)
#ifdef _WIN32
    closesocket(Client_pool[i]);
#else
    close(Client_pool[i]);
#endif

#ifdef _WIN32
closesocket(listenSock);
WSACleanup();
#else
close(listenSock);
#endif
```

### Client

同样的，首先实现客户端输入功能与接收回显的功能：

```c++
void input(SOCKET connSock) {
    char data[BUFFER_SIZE] = {};
    while (true) {
        cin.getline(data, BUFFER_SIZE);
        send(connSock, data, strlen(data) + 1, 0);
    }
}

int handler(SOCKET connSock) {
    char data[BUFFER_SIZE] = {};
    if (recv(connSock, data, BUFFER_SIZE, 0) > 0)
        cout << "recv msg: " << data << endl;
    else
        return -1;    // 服务器丢失

    return 0;
}
```

在成功连接服务器之后，客户端代码需要完成两件事：使用线程来托管输入功能，使用selecct模型来与服务器交互。

```c++
// 3. Connect to the server
// ...

// 4. Send and receive data
char cBuf[BUFFER_SIZE] = {};
if (recv(connSock, cBuf, BUFFER_SIZE, 0))
    cout << "recv msg: " << cBuf << endl;
std::thread t(input, connSock);    // #include <thread>
t.detach();    // 守护线程接管输入


while (true) {
    fd_set fdRead;    // fd读集合
    FD_ZERO(&fdRead);    // 读集合全部复位
    FD_SET(connSock, &fdRead);    // 监听套接字置位

    timeval t_val = { 1,0 };    // 阻塞时间1.0s
    if (select(connSock + 1, &fdRead, 0, 0, &t_val) < 0)
        break;    // 任务结束

    if (FD_ISSET(connSock, &fdRead))
        if (handler(connSock) == -1)
            break;    // 服务器丢失

    FD_CLR(connSock, &fdRead);

    cout << "idle time..." << endl;
}
```

需要注意的是select模型仍然属于阻塞模型，其阻塞时间由一个```timeval```格式的结构体来决定。

## 黏包

黏包是网络编程中老生常谈的问题了，主要原因就是因为缓冲区的存在，接收到的数据包都是无区分连续的存储在缓冲区中。为了能够精确地从缓冲区中取出一个单独且完整的数据包，必须要有方法能够从缓冲区的连续数据中区分出包与包之间的间隔。

常用的方法是双方协定一个数据格式，每个数据包分为header与body，其中header大小固定而body大小不定，每个数据包的body大小承载在header中，这样一来接收端就可以先接受header，然后再根据header中的信息再接收body。如下代码演示了一个简单的数据包格式：

```c++
class Header {
public:
	int cmd;    // 控制字段
	int length;    // 包体大小
};

class DataPack :public Header {
public:
	char data[2048] = "hello from client";
	DataPack() {
		this->cmd = 1;
		this->length = sizeof(DataPack) - sizeof(Header);
	}
};
```

## 缓冲区与阻塞

首先系统的socket自带缓冲区，可称为系统缓冲区。该缓冲区由系统托管，好处就是完全自动化。但是缺点在于很容易阻塞，当CS交互过快并且数据包比较大时，（通常接收端）系统缓冲区很容易被数据填满并得不到及时的清空，就会引发阻塞，这种阻塞即使关闭多余的连接也不会恢复，只能重连。因此为了避免系统缓冲区导致的阻塞，通常会在通信程序中再设立一个单独的程序缓冲区，由程序员管理。因为设立程序缓冲区的目的就是为了不让系统缓冲区阻塞，因此程序缓冲区一般会设的比系统缓冲区大。另一方面，程序缓冲区要尽可能快的将系统缓冲区中的数据搬运到自身，不然就没有存在的意义。

