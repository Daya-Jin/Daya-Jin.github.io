---
layout: post
title:  "C++ SOCKET"
categories: programming
tags: C++ socket
---

* content
{:toc}

## WinSock2

WinSock2是在Windows下实现socket编程的一个库。一个微软官方的简单C/S示例代码见此：([Server](https://github.com/Daya-Jin/CPP_Backend/blob/master/Socket/Demo/S.cpp)，[Client](https://github.com/Daya-Jin/CPP_Backend/blob/master/Socket/Demo/C.cpp))。可以看出一个最简单的单点C/S架构代码就比较复杂，这是因为官方Demo中加入了各种异常情况的处理。考虑到socket编程最需要关注的点在于收发步骤的逻辑实现，这里给出了一组简化版本的跨平台代码：([Server](https://github.com/Daya-Jin/CPP_Backend/blob/master/Socket/Demo/S_mini.cpp)，[Client](https://github.com/Daya-Jin/CPP_Backend/blob/master/Socket/Demo/C_mini.cpp))。

网络开发主要是围绕connecting、sending和receiving的逻辑来进行代码修改，函数API查询地址[见此](https://docs.microsoft.com/zh-cn/windows/win32/api/_winsock/)。

## select模型

上述示例代码有两个缺陷，一是阻塞模式，二是单点通信。在网络编程中有一种IO复用的select模型，由操作系统实现。其原型为：

```c++
select(_In_ int nfds,    // 最大fd的ID
       _Inout_opt_ fd_set FAR * readfds,    // 可读fd集合
       _Inout_opt_ fd_set FAR * writefds,    // 可写fd集合
       _Inout_opt_ fd_set FAR * exceptfds,    // 异常fd集合
       _In_opt_ const struct timeval FAR * timeout);    // 阻塞时间
```

```fd_set```本质是一个socket数组，实际是一个结构体，它还有一个成员变量记录了集合中socket的数量。对`fd集合的操作依赖如下几个宏：

```FD_ZERO()```：清空某个fd集合，该宏应该在初始化一个fd集合后马上调用；
```FD_SET()```：把一个fd加入到集合中，该宏能自动去重；
```FD_CLR()```：从集合中删除一个fd，即使不存在也不会报错；
```FD_ISSET()```：判断一个fd是否还在集合中。

在程序调用```select```函数之后会阻塞一段时间，直到超时或者任意fd发生事件。

## 非阻塞与线程

真正的服务器端应该支持多个客户端的加入，并且以非阻塞的模式处理与客户端的交互；而客户端也应该有专门的线程来处理交互事务。下面在程序代码中进行改造，使用```select```模型来实现端口复用支持单线程下的多客户端处理，而在客户端使用线程来处理用户输入。

select使用文件描述符```fd```来标记不同文件的状态，使用文件描述符集```fd_set```来存储所有```fd```不同类型的状态。有三种类型的状态：read、write和except。在创建```fd_set```之后，需要使用```FD_ZERO```进行清零，```FD_SET```和```FD_CLR```分别用于置位和复位，```FD_ISSET```用于判断是否置位。每次使用```select```函数，其会返回一个有事件发生的fd总数，并且把那些没有事件发生的fd复位。

Server端，首先将IO逻辑封装成函数：

```c++
int logic(SOCKET ClientSocket)
{
	DataPack recvDp = {};
	if (recv(ClientSocket, (char*)&recvDp, sizeof(DataPack), 0) <= 0)
	{
		printf("client exit!\n");
		return -1;
	}

	printf("[DEBUG]recvDp.flag: %d, recvDp.s: %s\n", recvDp.flag, recvDp.s);

	DataPack sendDp;
	switch (recvDp.flag)
	{
	case LOGIN:
		if (strcmp(recvDp.s, "123456") == 0)    // 固定密码
		{
			sendDp.flag = NORMAL;
			strcpy(sendDp.s, "login!");
		}
		else
		{
			sendDp.flag = ERR;
			strcpy(sendDp.s, "pswd err!");
		}
		
		break;
	case LOGOUT:
		sendDp.flag = NORMAL;
		strcpy(sendDp.s, "logout!");
		break;
	case NORMAL:
		sendDp.flag = NORMAL;
		strcpy(sendDp.s, "normal msg!");
		break;
	default:
		recvDp.flag = ERR;
		strcpy(recvDp.s, "unknow err!");
		break;
	}

	send(ClientSocket, (char*)&sendDp, sizeof(DataPack), 0);
	printf("[DEBUG]sendDp.flag: %d, sendDp.s: %s\n",
		sendDp.flag, sendDp.s);

	return 0;
}
```

再在```S.cpp```中加入select模型：

```c++
// 4. Listen on the socket
// ...

std::vector<SOCKET> Client_pool;
char sBuf[] = "hello from server.";
while (true)
{
    fd_set fdRead;    // fd读集合
    FD_ZERO(&fdRead);    // 读集合全部复位
    FD_SET(ListenSocket, &fdRead);    // 监听套接字置位
    SOCKET nfds = ListenSocket;    // 最大fd
    // 将所有客户套接字置位
    for (int i = 0; i < (int)Client_pool.size(); i++)
    {
        FD_SET(Client_pool[i], &fdRead);
        if (nfds < Client_pool[i])
            nfds = Client_pool[i];
    }

    timeval t_val = { 1,0 };    // 等待时间1.0s
    if (select(nfds + 1, &fdRead, 0, 0, &t_val) < 0)
        break;    // 任务结束

    // 处理监听套接字
    if (FD_ISSET(ListenSocket, &fdRead))
    {
        // 5. Accept a connection
        sockaddr_in _cin = {};
        int len = sizeof(sockaddr_in);
#ifdef _WIN32
        SOCKET ClientSocket = accept(ListenSocket, (sockaddr*)&_cin, &len);
#else
        SOCKET ClientSocket = accept(ListenSocket, (sockaddr*)&_cin, (socklen_t*)&len);
#endif
        if (INVALID_SOCKET == ClientSocket)
            printf("scoket invalid!\n");
        Client_pool.push_back(ClientSocket);

        send(ClientSocket, sBuf, strlen(sBuf) + 1, 0);
        printf("recv a new client: IP %s\n", inet_ntoa(_cin.sin_addr));

        FD_CLR(ListenSocket, &fdRead);    // fd复位
    }

    // 轮询有事件发生的客户端套接字
    for (int i = Client_pool.size() - 1; i >= 0; i--)
    {
        if (FD_ISSET(Client_pool[i], &fdRead))
        {
            /*判断client是否退出，并删除client的socket*/
            if (logic(Client_pool[i]) == -1)
            {
                std::vector<SOCKET>::iterator iter = Client_pool.begin() + i;
                if (iter != Client_pool.end())
                    Client_pool.erase(iter);
            }
        }
    }
    // printf("idle time...\n");
}

for (int i = (int)Client_pool.size() - 1; i >= 0; i--)
#ifdef _WIN32
    closesocket(Client_pool[i]);
#else
    close(Client_pool[i]);
#endif

// 7. Disconnect
```

类似地，先将客户端的IO逻辑与线程内容封装成函数：

```c++
bool Online = true;    // 全局变量
void inputFunc(SOCKET ConnectSocket)
{
	char Buf[BUFFER_SIZE] = {};
	while (true)
	{
		scanf("%s", Buf);

		if (strcmp(Buf, "exit") == 0)
			break;
		else if (strcmp(Buf, "login") == 0)
		{
			DataPack sendDp;
			printf("enter your pswd:");
			scanf("%s", sendDp.s);
			send(ConnectSocket, (const char*)&sendDp, sizeof(DataPack), 0);
		}
		else if (strcmp(Buf, "logout") == 0)
		{
			DataPack sendDp;
			sendDp.flag = LOGOUT;
			strcpy(sendDp.s, "username");
			send(ConnectSocket, (const char*)&sendDp, sizeof(DataPack), 0);
		}
		else
			printf("unknow cmd\n");
	}
}

int logic(SOCKET ConnectSocket)
{
	DataPack recvDp = {};
	if (recv(ConnectSocket, (char*)&recvDp, sizeof(DataPack), 0) <= 0)
		return -1;
	else
		printf("recv msg: %s\n", recvDp.s);

	return 0;
}
```

再在```C.cpp```中加入select模型：

```c++
// 4. Send and receive data
// ...

std::thread t(inputFunc, ConnectSocket);    // #include<thread>
t.detach();

while (Online)
{
    fd_set fdRead;    // fd读集合
    FD_ZERO(&fdRead);    // 读集合全部复位
    FD_SET(ConnectSocket, &fdRead);    // 监听套接字置位

    timeval t_val = { 1,0 };    // 等待时间1.0s
    if (select(ConnectSocket+1, &fdRead, 0, 0, &t_val) < 0)
        break;    // 任务结束

    if (FD_ISSET(ConnectSocket, &fdRead))
        if (logic(ConnectSocket) == -1)
        {
            printf("server missing!\n");
            break;
        }
    FD_CLR(ConnectSocket, &fdRead);

    // printf("idle time...\n");
}

// 5. Disconnect
```
