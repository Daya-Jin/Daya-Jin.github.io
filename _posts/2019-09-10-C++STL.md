---
layout: post
title:  "C++ STL"
categories: programming
tags: C++
---

* content
{:toc}

## 容器

### Vector

C++中的Vector相当于动态数组，连续存储空间，支持随机存取，可根据元素数量自动扩展内存。

```c++
#include<iostream>
#include<vector>
using namespace std;

int main()
{
	vector<int> v;
	v.reserve(10);    // 预分配空间

	v = { 0,1,2,4 };
	v.emplace(v.begin() + 3, 3);
	if (!v.empty())
		v.emplace_back(5);

	for (int i = 0; i < v.size(); i++)
		cout << v[i] << " ";

	cout << "size: " << v.size() << " capacity:" << v.capacity() << endl;
	v.shrink_to_fit();    // 释放内存
	cout << "size: " << v.size() << " capacity:" << v.capacity() << endl;

	return 0;
}
```

### String

```c++
#include<iostream>
#include<string>
using namespace std;

int main()
{
	char s1[] = "hello";
	string s2 = s1;
	s2 += " world";
	s2[5] = '_';
	cout << s2 << endl;
	cout << s2.substr(0, s2.find('_')) << endl;

	return 0;
}
```

### Set

C++中的Set是有序集合，内部不允许存在重复元素。

```c++
#include<iostream>
#include<set>
using namespace std;

int main()
{
	set<int> s = { 3,2,1,0 };
	s.insert(1);
	s.erase(3);

	if (s.find(0) != s.end())
		cout << "0 is in s" << endl;
	else
		cout << "0 is not in s" << endl;

	for (set<int>::iterator i = s.begin(); i != s.end(); i++)
		cout << *i << ' ';

	return 0;
}
```

### Map

C++中的Map是有序哈希表。

```c++
#include<iostream>
#include<map>
using namespace std;

int main()
{
	map<int, int> table = { {3,30},
							{1,10} };
	table[2] = 20;
	table.erase(1);

	map<int, int>::iterator i = table.find(2);
	if (i != table.end())
		cout << "key: " << i->first
		<< " val: " << i->second << endl;

	return 0;
}
```

## 迭代器



## 仿函数

由于运算符重载机制的存在，当重载```()```运算符时，对象便可以模仿函数的行为。仅实现了```()```重载的对象称为仿函数。仿函数主要是配合STL使用的，那么为什么要用仿函数而不用普通函数呢？首先看一下普通函数能做的，下述代码使用函数指针来实现逆序排序：

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

bool Greater(const int& x, const int& y) {
	return x > y;
}

int main()
{
	vector<int> v = { 3,1,2 };
	sort(v.begin(), v.end(), Greater);
	for (int i = 0; i < v.size(); i++)
		cout << v[i] << ' ';    // 3 2 1

	return 0;
}
```

```sort```只是```algorithm```组件中的一个方法，STL包含的算法还有很多，如```count_if```，假设现有如下需求，设定一个阈值，统计出数组中大于该阈值的元素个数。如果用函数指针思路来实现的话是这样的：

```c++
bool GT(const int& i, const int& thresh) {
	return i > thresh;
}

int main()
{
	vector<int> v = { -1,-5,1,6,7 };
	int res = count_if(v.begin(), v.end(), GT);
	cout << res << endl;
	return 0;
}
```

然而上述代码会报错，原因就在于```count_if```的谓词参数是Unary的，即只接受一元谓词，上述代码如果要改的话只能将```thresh```写成全局变量。相比于普通函数，仿函数的好处在于可以以成员属性的方式来隐藏一些状态。在该例子中，使用仿函数来实现的代码如下所示：

```c++
class GT {
	int thresh;
public:
	GT(const int& thresh) {
		this->thresh = thresh;
	}

	bool operator()(const int& i) {
		return i > this->thresh;
	}
};

int main()
{
	vector<int> v = { -1,-5,1,6,7 };
	int res = count_if(v.begin(), v.end(), GT(0));
	cout << res << endl;
	return 0;
}
```

## 算法

### Sort
