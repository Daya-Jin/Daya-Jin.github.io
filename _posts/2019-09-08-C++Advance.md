---
layout: post
title:  "C++ Advance"
categories: programming
tags: C++
---

* content
{:toc}

## 友元与运算符重载

运算符重载等同于函数重载，原生运算符仅支持少数几个数据类型，重载运算符可支持自定义类型。现定义一个二维向量类：

```c++
class Vec
{
	double x;
	double y;

public:
	Vec(double x, double y);
}

Vec::Vec(double x = 0, double y = 0) {
	this->x = x;
	this->y = y;
}
```

要求为该类实现乘法，有三种：```Vec*Vec```、```Vec*x```和```x*Vec```。前两种乘法可直接使用成员函数来实现，如下所示：

```c++
Vec Vec::operator*(const Vec& v) {
	Vec res;
	res.x = this->x * v.x;
	res.y = this->y * v.y;
	return res;
}

Vec Vec::operator*(double r) {
	Vec res;
	res.x = this->x * r;
	res.y = this->y * r;
	return res;
}
```

问题是第三种。第三种乘法```x*Vec```因为向量类在右边，所以不能使用成员函数来实现，但是使用非成员函数的话会存在访问权限问题。C++中友元关键字```friend```修饰的函数和对象可访问类的私有属性。因此```Vec.h```内容为：

```c++
#include<iostream>
using namespace std;

class Vec
{
	double x;
	double y;

public:
	Vec(double x, double y);
	Vec operator*(const Vec& v);    // Vec*Vec
	Vec operator*(double r);    // Vec*r
	friend Vec operator*(double r, const Vec& v);    // r*Vec, 友元函数可访问私有属性
	friend ostream& operator<<(ostream& cout, const Vec& v);    // 重载输出
};
```

而```Vec.cpp```内容为：

```c++
#include<iostream>
#include "Vec.h"
using namespace std;

Vec::Vec(double x = 0, double y = 0) {
	this->x = x;
	this->y = y;
}

Vec Vec::operator*(const Vec& v) {
	Vec res;
	res.x = this->x * v.x;
	res.y = this->y * v.y;
	return res;
}

Vec Vec::operator*(double r) {
	Vec res;
	res.x = this->x * r;
	res.y = this->y * r;
	return res;
}

Vec operator*(double r, const Vec& v) {
	Vec res;
	res.x = r * v.x;
	res.y = r * v.y;
	return res;
}

ostream& operator<<(ostream& cout, const Vec& v) {
	cout << "<" << v.x << ", " << v.y << ">";
	return cout;    // 为了支持连续输出
}
```

## 模版

### 函数模版

函数模版与函数重载的区别：
- 函数模版对不同数据类型的处理逻辑是一模一样的，而重载函数的逻辑可以不一样；
- 在参数数量不同或者逻辑不同的情况下只能使用函数重载，否则可以使用函数模版；
- 模版也是可重载的，主要解决参数数量不同和逻辑不同的问题。

```c++
#include<iostream>
using namespace std;

template<typename T>
void Swap(T* a, T* b) {
	T tmp = *a;
	*a = *b;
	*b = tmp;
}

int main(void) {
	int a = 1;
	int b = 2;
	Swap<int>(&a, &b);
	cout << a << ' ' << b << endl;

	float c = 1.0f;
	float d = 2.0f;
	Swap<float>(&c, &d);
	cout << c << ' ' << d << endl;

	return 0;
}

```

### 类模板

```c++
#include<iostream>
#include<string>
using namespace std;

template <typename T_key, typename T_val>
class Pair {
	T_key key;
	T_val val;
public:
	Pair(T_key key, T_val val) {
		this->key = key;
		this->val = val;
	};
	void Print() {
		cout << this->key << ": " << this->val;
	}
};

int main()
{
	Pair<string, int> p1 = Pair<string, int>("key1", 1);
	p1.Print();
	return 0;
}
```